<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pepe Pattern Viewer</title>
  <style>
    body { background: #222; color: #eee; margin: 0; padding: 0; }
    #mainCanvasContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      width: 100vw;
    }
    canvas { background: #fff; margin: 20px auto; display: block; box-shadow: 0 2px 16px #0006; }
    #settingsOverlay {
      position: fixed;
      top: 0; left: 0; width: 100vw; height: 100vh;
      background: #222e;
      display: none;
      z-index: 100;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    #settingsPanel {
      background: #333;
      padding: 30px 20px 20px 20px;
      border-radius: 16px;
      box-shadow: 0 4px 32px #000a;
      max-width: 440px;
      width: 90vw;
      max-height: 90vh;
      overflow-y: auto;
      position: relative;
      margin: auto;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #showSettingsTab {
      position: fixed;
      top: 40px;
      right: 0;
      background: #4caf50;
      color: #fff;
      border-radius: 8px 0 0 8px;
      padding: 12px 24px 12px 12px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      z-index: 101;
      box-shadow: -2px 2px 10px #0006;
      transition: background 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #showSettingsTab:hover {
      background: #388e3c;
    }
    #closeSettingsBtn {
      position: absolute;
      top: 12px;
      left: 12px;
      background: #222;
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 6px 14px;
      font-size: 1em;
      cursor: pointer;
      box-shadow: 0 2px 8px #0004;
      transition: background 0.2s;
    }
    #closeSettingsBtn:hover {
      background: #444;
    }
    .form-section {
      margin: 0 auto;
      background: #333;
      padding: 0;
      border-radius: 10px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 16px;
      align-items: center;
    }
    .form-row {
      display: flex;
      align-items: center;
      width: 100%;
      justify-content: center;
      gap: 10px;
    }
    .form-section label {
      min-width: 110px;
      text-align: right;
      margin-right: 10px;
      flex-shrink: 0;
    }
    .form-section input[type="number"] { width: 60px; }
    .form-section input[type="color"] { width: 40px; height: 30px; vertical-align: middle; }
    .form-section input[type="range"] { width: 120px; }
    .button-row label { min-width: 80px; text-align: right; }
    .off-label { margin-left: 10px; }
    .switch-group {
      display: flex;
      gap: 8px;
      margin-left: 5px;
    }
    .switch-radio {
      appearance: none;
      width: 22px;
      height: 22px;
      border: 2px solid #888;
      border-radius: 50%;
      background: #222;
      cursor: pointer;
      transition: border-color 0.2s, box-shadow 0.2s;
      position: relative;
    }
    .switch-radio:checked {
      border-color: #4caf50;
      box-shadow: 0 0 0 2px #4caf5055;
      background: #4caf50;
    }
    .button-row {
      display: flex;
      align-items: center;
      width: 100%;
      justify-content: center;
      gap: 10px;
    }
    #buttonInputs > div {
      display: inline-block;
      margin: 0 2px;
      vertical-align: middle;
    }
    @media (max-width: 600px) {
      #settingsPanel {
        max-width: 98vw;
        padding: 18px 2vw 10px 2vw;
      }
      .form-section label { min-width: 80px; font-size: 0.95em; }
      #showSettingsTab { font-size: 1em; padding: 10px 18px 10px 8px; }
    }
  </style>
</head>
<body>
  <div id="mainCanvasContainer">
    <h1>Pepe Pattern Viewer</h1>
    <canvas id="patternCanvas"></canvas>
    <button id="generateBtn">Generate New Pattern</button>
    <div style="margin-top:10px;">
      <button id="backBtn" disabled>&#8592; Go Back</button>
      <button id="forwardBtn" disabled>Go Forward &#8594;</button>
      <button id="printBtn">üñ®Ô∏è Print Instructions</button>
    </div>
  </div>
  <div id="showSettingsTab">
    <span style="font-size:1.3em;">&#9654;</span> PepesMachine
  </div>
  <div id="settingsOverlay">
    <div id="settingsPanel">
      <button id="closeSettingsBtn">&#8592; Back to Canvas</button>
      <form id="settingsForm" class="form-section">
        <div class="form-row">
          <label for="knob_down">Zoom:</label>
          <input type="range" id="knob_down" name="knob_down" min="1" max="10" step="1">
          <span id="zoomValue"></span>
        </div>
        <div class="form-row">
          <label for="slider">Slider:</label>
          <input type="range" id="slider" name="slider" min="0" max="100">
          <span id="sliderValue"></span>
        </div>
        <div class="form-row">
          <label>Switch:</label>
          <span class="switch-group">
            <input type="radio" id="switch_left" class="switch-radio" name="switch" value="left">
            <input type="radio" id="switch_center" class="switch-radio" name="switch" value="center">
            <input type="radio" id="switch_right" class="switch-radio" name="switch" value="right">
          </span>
        </div>
        <div class="form-row">
          <label for="canvas_width">Canvas Width:</label>
          <input type="number" id="canvas_width" name="canvas_width" min="10" max="1000" required>
        </div>
        <div class="form-row">
          <label for="canvas_height">Canvas Height:</label>
          <input type="number" id="canvas_height" name="canvas_height" min="10" max="1000" required>
        </div>
        <div class="button-row">
          <label>Buttons:</label>
          <div>
            <span id="buttonInputs"></span>
          </div>
        </div>
        <!-- Removed the Save Settings button -->
      </form>
    </div>
  </div>
  <script>
    // Helper to load JSON
    async function loadJSON(url) {
      const resp = await fetch(url);
      return await resp.json();
    }

    // Helper to POST JSON
    async function postJSON(url, data) {
      await fetch(url, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(data)
      });
    }

    // Dynamically create button color/off inputs
    function renderButtonInputs(data) {
      const container = document.getElementById('buttonInputs');
      container.innerHTML = '';
      for (let i = 0; i <= 9; i++) {
        const btnKey = `button_${i}`;
        const value = data[btnKey] || 'off';
        const color = (value !== 'off') ? value : '#ffffff';
        const checked = (value === 'off') ? 'checked' : '';
        container.innerHTML += `
          <div style="display:inline-block; margin:0 5px;">
            <label for="${btnKey}">#${i}</label>
            <input type="color" id="${btnKey}" name="${btnKey}" value="${color}">
            <input type="checkbox" id="${btnKey}_off" name="${btnKey}_off" ${checked}>
            <label for="${btnKey}_off" class="off-label">off</label>
          </div>
        `;
      }
      attachAutoSave(); // Re-attach after rendering

      // Add event listeners for color inputs to auto-uncheck "off"
      for (let i = 0; i <= 9; i++) {
        const btnKey = `button_${i}`;
        const colorInput = document.getElementById(btnKey);
        const offCheckbox = document.getElementById(btnKey + '_off');
        colorInput.addEventListener('input', function() {
          offCheckbox.checked = false;
          autoSaveAndGenerate();
        });
        offCheckbox.addEventListener('change', function() {
          autoSaveAndGenerate();
        });
      }
    }

    // Fill form with data.json values
    async function fillForm() {
      const data = await loadJSON('data.json');
      document.getElementById('knob_down').value = data.knob_down || 1;
      document.getElementById('zoomValue').textContent = data.knob_down || 1;
      document.getElementById('slider').value = data.slider || 0;
      document.getElementById('sliderValue').textContent = data.slider || 0;
      if (data.switch === 'left') document.getElementById('switch_left').checked = true;
      else if (data.switch === 'right') document.getElementById('switch_right').checked = true;
      else document.getElementById('switch_center').checked = true;
      document.getElementById('canvas_width').value = data.canvas_width || 500;
      document.getElementById('canvas_height').value = data.canvas_height || 500;
      renderButtonInputs(data);
    }

    // Update zoom slider value display
    document.getElementById('knob_down').oninput = function() {
      document.getElementById('zoomValue').textContent = this.value;
    };

    // Update slider value display
    document.getElementById('slider').oninput = function() {
      document.getElementById('sliderValue').textContent = this.value;
    };

    // Save form to data.json and generate new pattern
    async function autoSaveAndGenerate() {
      const data = {};
      data.knob_down = parseInt(document.getElementById('knob_down').value);
      data.slider = parseInt(document.getElementById('slider').value);
      data.switch = document.querySelector('input[name="switch"]:checked').value;
      data.canvas_width = parseInt(document.getElementById('canvas_width').value);
      data.canvas_height = parseInt(document.getElementById('canvas_height').value);
      for (let i = 0; i <= 9; i++) {
        const btnKey = `button_${i}`;
        const colorInput = document.getElementById(btnKey);
        const offCheckbox = document.getElementById(btnKey + '_off');
        data[btnKey] = offCheckbox.checked ? 'off' : colorInput.value;
      }
      await postJSON('/data.json', data);
      await generateAndSaveHistory();
    }

    // Attach auto-save to all inputs in the form
    function attachAutoSave() {
      const form = document.getElementById('settingsForm');
      form.querySelectorAll('input').forEach(input => {
        input.oninput = autoSaveAndGenerate;
        input.onchange = autoSaveAndGenerate;
      });
    }

    // Drawing logic (unchanged)
    function resolveColor(c) {
      if (!c) return "#000";
      return c;
    }

    function drawTile(ctx, tile, x, y, size) {
      ctx.save();
      ctx.translate(x + size/2, y + size/2);
      ctx.rotate((tile.rotation || 0) * Math.PI / 180);
      ctx.translate(-size/2, -size/2);

      // Background
      ctx.fillStyle = resolveColor(tile.color_fundo);
      ctx.fillRect(0, 0, size, size);

      if (tile.tile === "Padrao Quadrado") {
        ctx.fillStyle = resolveColor(tile.color_padrao);
        ctx.fillRect(0, 0, size/2, size);
      } else if (tile.tile === "Padrao Triangulos") {
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(size, 0);
        ctx.lineTo(0, size);
        ctx.closePath();
        ctx.fillStyle = resolveColor(tile.color_padrao);
        ctx.fill();
      }
      ctx.restore();
    }

    async function drawPattern() {
      const pattern = await loadJSON('pattern.json');
      const data = await loadJSON('data.json');
      const canvas = document.getElementById('patternCanvas');
      const width = data.canvas_width || 500;
      const height = data.canvas_height || 500;
      canvas.width = width;
      canvas.height = height;

      let maxX = 0, maxY = 0;
      pattern.forEach(tile => {
        if (tile.grid_x > maxX) maxX = tile.grid_x;
        if (tile.grid_y > maxY) maxY = tile.grid_y;
      });
      const cols = maxX;
      const rows = maxY;
      const tileSize = Math.min(width / cols, height / rows);
      const offsetX = (width - tileSize * cols) / 2;
      const offsetY = (height - tileSize * rows) / 2;

      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, width, height);

      pattern.forEach(tile => {
        const x = offsetX + (tile.grid_x - 1) * tileSize;
        const y = offsetY + (tile.grid_y - 1) * tileSize;
        drawTile(ctx, tile, x, y, tileSize);
      });
    }

    // Pattern history management
    let patternHistory = [];
    let historyIndex = -1;
    let debounceTimer = null;

    function patternsAreEqual(a, b) {
      return JSON.stringify(a) === JSON.stringify(b);
    }

    function loadHistory() {
      const hist = localStorage.getItem('patternHistory');
      if (hist) {
        patternHistory = JSON.parse(hist);
        historyIndex = parseInt(localStorage.getItem('historyIndex')) || (patternHistory.length - 1);
      }
      updateHistoryButtons();
    }

    function saveHistory() {
      localStorage.setItem('patternHistory', JSON.stringify(patternHistory));
      localStorage.setItem('historyIndex', historyIndex);
      updateHistoryButtons();
    }

    function updateHistoryButtons() {
      document.getElementById('backBtn').disabled = historyIndex <= 0;
      document.getElementById('forwardBtn').disabled = historyIndex >= patternHistory.length - 1;
    }

    async function fetchCurrentPattern() {
      return await loadJSON('pattern.json');
    }

    async function drawPatternFromHistory(idx) {
      if (patternHistory[idx]) {
        const pattern = patternHistory[idx];
        const data = await loadJSON('data.json');
        const canvas = document.getElementById('patternCanvas');
        const width = data.canvas_width || 500;
        const height = data.canvas_height || 500;
        canvas.width = width;
        canvas.height = height;

        let maxX = 0, maxY = 0;
        pattern.forEach(tile => {
          if (tile.grid_x > maxX) maxX = tile.grid_x;
          if (tile.grid_y > maxY) maxY = tile.grid_y;
        });
        const cols = maxX;
        const rows = maxY;
        const tileSize = Math.min(width / cols, height / rows);
        const offsetX = (width - tileSize * cols) / 2;
        const offsetY = (height - tileSize * rows) / 2;

        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, width, height);

        pattern.forEach(tile => {
          const x = offsetX + (tile.grid_x - 1) * tileSize;
          const y = offsetY + (tile.grid_y - 1) * tileSize;
          drawTile(ctx, tile, x, y, tileSize);
        });
      }
      updateHistoryButtons();
    }

    // On new generation, add to history (debounced)
    async function generateAndSaveHistory() {
      await fetch('/generate', {method: 'POST'});
      setTimeout(async () => {
        const pattern = await fetchCurrentPattern();
        // If we're not at the end, cut forward history
        if (historyIndex < patternHistory.length - 1) {
          patternHistory = patternHistory.slice(0, historyIndex + 1);
        }
        // Avoid duplicates
        if (patternHistory.length === 0 || !patternsAreEqual(pattern, patternHistory[patternHistory.length - 1])) {
          patternHistory.push(pattern);
          // Limit history to 20 generations
          if (patternHistory.length > 20) {
            patternHistory = patternHistory.slice(patternHistory.length - 20);
          }
          historyIndex = patternHistory.length - 1;
          saveHistory();
        } else {
          // If duplicate, just update index
          historyIndex = patternHistory.length - 1;
          saveHistory();
        }
        drawPatternFromHistory(historyIndex);
      }, 300);
    }

    document.getElementById('generateBtn').onclick = generateAndSaveHistory;

    document.getElementById('backBtn').onclick = function() {
      if (historyIndex > 0) {
        historyIndex--;
        saveHistory();
        drawPatternFromHistory(historyIndex);
      }
    };

    document.getElementById('forwardBtn').onclick = function() {
      if (historyIndex < patternHistory.length - 1) {
        historyIndex++;
        saveHistory();
        drawPatternFromHistory(historyIndex);
      }
    };

    // Debounced auto-save and generate
    async function autoSaveAndGenerate() {
      const data = {};
      data.knob_down = parseInt(document.getElementById('knob_down').value);
      data.slider = parseInt(document.getElementById('slider').value);
      data.switch = document.querySelector('input[name="switch"]:checked').value;
      data.canvas_width = parseInt(document.getElementById('canvas_width').value);
      data.canvas_height = parseInt(document.getElementById('canvas_height').value);
      for (let i = 0; i <= 9; i++) {
        const btnKey = `button_${i}`;
        const colorInput = document.getElementById(btnKey);
        const offCheckbox = document.getElementById(btnKey + '_off');
        data[btnKey] = offCheckbox.checked ? 'off' : colorInput.value;
      }
      await postJSON('/data.json', data);

      // Debounce pattern generation
      if (debounceTimer) clearTimeout(debounceTimer);
      debounceTimer = setTimeout(generateAndSaveHistory, 400);
    }

    // Overlay logic
    const settingsOverlay = document.getElementById('settingsOverlay');
    const showSettingsTab = document.getElementById('showSettingsTab');
    const closeSettingsBtn = document.getElementById('closeSettingsBtn');
    const settingsPanel = document.getElementById('settingsPanel');

    showSettingsTab.onclick = function() {
      settingsOverlay.style.display = 'flex';
      showSettingsTab.style.display = 'none';
    };
    closeSettingsBtn.onclick = function() {
      settingsOverlay.style.display = 'none';
      showSettingsTab.style.display = 'flex';
    };
    // Click outside panel closes overlay
    settingsOverlay.onclick = function(e) {
      if (e.target === settingsOverlay) {
        settingsOverlay.style.display = 'none';
        showSettingsTab.style.display = 'flex';
      }
    };

    // Initial load
    fillForm().then(attachAutoSave);
    loadHistory();
    // If history exists, draw last pattern, else draw current
    if (patternHistory.length > 0) {
      drawPatternFromHistory(historyIndex);
    } else {
      drawPattern();
    }

    // Generate drawing instructions from a pattern array
    function getDrawingInstructions(pattern) {
      let instructions = [];
      pattern.forEach((tile, idx) => {
        instructions.push(
          `Tile ${idx + 1}: Type=${tile.tile}, Grid=(${tile.grid_x},${tile.grid_y}), Rotation=${tile.rotation || 0}, ` +
          `Background=${tile.color_fundo}, PatternColor=${tile.color_padrao}`
        );
      });
      return instructions.join('\n');
    }

    // Print button logic
    document.getElementById('printBtn').onclick = function() {
      let pattern = patternHistory[historyIndex];
      if (!pattern) return;
      const instructions = getDrawingInstructions(pattern);
      const blob = new Blob([instructions], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `pepe_pattern_instructions.txt`;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    };
  </script>
</body>
</html>