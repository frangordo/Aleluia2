<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=BBH+Sans+Hegarty&family=Offside&family=Rajdhani:wght@300;400;500;600;700&family=Silkscreen:wght@400;700&display=swap" rel="stylesheet">
  <title>PepesMachine</title>
  <style>
    body { background: #ffffff; color: #210e99; margin: 0; padding: 0; }
    /* swatch styles for color icons (active/inactive) */
    .swatch {
      width: 30px;
      height: 30px;
      border-radius: 6px;
      border: 2px transparent solid;
      display: inline-block;
      cursor: pointer;
      vertical-align: middle;
      box-sizing: border-box;
    }
    h1 { 
      margin-top: 20px;
      font-family: "Rajdhani", sans-serif;
      font-size: 2vw;
      font-style: bold;
    }
    .swatch.inactive {
      background: repeating-linear-gradient(45deg,#ddd,#ddd 6px,#fff 6px,#fff 12px);
      opacity: 0.8;
      border-color: #444;
    }
    #mainCanvasContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      width: 100vw;
    }
    canvas { background: #fff; margin: 20px auto; display: block; box-shadow: 0 2px 16px #0006; }
    #settingsOverlay {
      position: fixed;
      top: 0; left: 0; width: 100vw; height: 100vh;
      background: #222e;
      display: none;
      z-index: 100;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    #settingsPanel {
      background: #333;
      padding: 30px 20px 20px 20px;
      border-radius: 16px;
      box-shadow: 0 4px 32px #000a;
      max-width: 440px;
      width: 90vw;
      max-height: 90vh;
      overflow-y: auto;
      position: relative;
      margin: auto;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #showSettingsTab {
      position: fixed;
      top: 40px;
      right: 0;
      background: #4caf50;
      color: #fff;
      border-radius: 8px 0 0 8px;
      padding: 12px 24px 12px 12px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      z-index: 101;
      box-shadow: -2px 2px 10px #0006;
      transition: background 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #showSettingsTab:hover {
      background: #388e3c;
    }
    #closeSettingsBtn {
      position: absolute;
      top: 12px;
      left: 12px;
      background: #222;
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 6px 14px;
      font-size: 1em;
      cursor: pointer;
      box-shadow: 0 2px 8px #0004;
      transition: background 0.2s;
    }
    #closeSettingsBtn:hover {
      background: #444;
    }
    .form-section {
      margin: 0 auto;
      background: #333;
      padding: 0;
      border-radius: 10px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 16px;
      align-items: center;
    }
    .form-row {
      display: flex;
      align-items: center;
      width: 100%;
      justify-content: center;
      gap: 10px;
    }
    .form-section label {
      min-width: 110px;
      text-align: right;
      margin-right: 10px;
      flex-shrink: 0;
    }
    .form-section input[type="number"] { width: 60px; }
    .form-section input[type="color"] { width: 40px; height: 30px; vertical-align: middle; }
    .form-section input[type="range"] { width: 120px; }
    .button-row label { min-width: 80px; text-align: right; }
    .off-label { margin-left: 10px; }
    .switch-group {
      display: flex;
      gap: 8px;
      margin-left: 5px;
    }
    .switch-radio {
      appearance: none;
      width: 22px;
      height: 22px;
      border: 2px solid #888;
      border-radius: 50%;
      background: #222;
      cursor: pointer;
      transition: border-color 0.2s, box-shadow 0.2s;
      position: relative;
    }
    .switch-radio:checked {
      border-color: #4caf50;
      box-shadow: 0 0 0 2px #4caf5055;
      background: #4caf50;
    }
    .button-row {
      display: flex;
      align-items: center;
      width: 100%;
      justify-content: center;
      gap: 10px;
    }
    #buttonInputs > div {
      display: inline-block;
      margin: 0 2px;
      vertical-align: middle;
    }
    @media (max-width: 600px) {
      #settingsPanel {
        max-width: 98vw;
        padding: 18px 2vw 10px 2vw;
      }
      .form-section label { min-width: 80px; font-size: 0.95em; }
      #showSettingsTab { font-size: 1em; padding: 10px 18px 10px 8px; }
    }
  </style>
</head>
<body>
  <div id="mainCanvasContainer">
    <h1>PEPESMACHINE</h1>
    <canvas id="patternCanvas"></canvas>
    <button id="generateBtn">Generate New Pattern</button>
    <div style="margin-top:10px;">
      <button id="backBtn" disabled>&#8592; Go Back</button>
      <button id="forwardBtn" disabled>Go Forward &#8594;</button>
      <button id="printBtn">üñ®Ô∏è Print Instructions</button>
    </div>
  </div>
  <div id="showSettingsTab">
    <span style="font-size:1.3em;">&#9654;</span> PepesMachine
  </div>
  <div id="settingsOverlay">
    <div id="settingsPanel">
      <button id="closeSettingsBtn">&#8592; Back to Canvas</button>
      <form id="settingsForm" class="form-section">
        <div class="form-row">
          <label for="knob_down">Zoom:</label>
          <input type="range" id="knob_down" name="knob_down" min="1" max="10" step="1">
          <span id="zoomValue"></span>
        </div>
        <div class="form-row">
          <label for="slider">Slider:</label>
          <input type="range" id="slider" name="slider" min="0" max="100">
          <span id="sliderValue"></span>
        </div>
        <div class="form-row">
          <label>Switch:</label>
          <span class="switch-group">
            <input type="radio" id="switch_left" class="switch-radio" name="switch" value="left">
            <input type="radio" id="switch_center" class="switch-radio" name="switch" value="center">
            <input type="radio" id="switch_right" class="switch-radio" name="switch" value="right">
          </span>
        </div>
        <div class="form-row">
          <label for="canvas_width">Canvas Width:</label>
          <input type="number" id="canvas_width" name="canvas_width" min="10" max="1000000" required>
        </div>
        <div class="form-row">
          <label for="canvas_height">Canvas Height:</label>
          <input type="number" id="canvas_height" name="canvas_height" min="10" max="1000000" required>
        </div>
        <div class="button-row">
          <label>Buttons:</label>
          <div>
            <span id="buttonInputs"></span>
          </div>
        </div>
        <!-- Removed the Save Settings button -->
      </form>
    </div>
  </div>
  <script>
    // Default button colors (will be used as fallback and initial palette)
    const DEFAULT_BUTTON_COLORS = [
      "#ff66de","#f98686","#7081ff","#62fe74","#fcff4d",
      "#ff7b24","#bd7ef1","#ffffff","#007EA7","#3517ab"
    ];

    // Persist session id via localStorage (survives browser restarts).
    // We still set a cookie from localStorage so fetch requests include it.
    function ensureSessionId() {
      let sid = localStorage.getItem('session_id');
      if (!sid) {
        sid = (crypto && crypto.randomUUID) ? crypto.randomUUID() : ('s' + Date.now() + '-' + Math.random().toString(36).slice(2,10));
        localStorage.setItem('session_id', sid);
      }
      // Mirror into a cookie so server request handlers can read it
      // Cookie is intentionally session-length (no expires) but is overwritten on load from localStorage.
      document.cookie = 'session_id=' + encodeURIComponent(sid) + '; path=/';
    }
    ensureSessionId();

    // Helper to load JSON
    async function loadJSON(url) {
      const resp = await fetch(url, { credentials: 'same-origin' });
      return await resp.json();
    }

    // Helper to POST JSON
    async function postJSON(url, data) {
      await fetch(url, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(data),
        credentials: 'same-origin'
      });
    }

    // Dynamically create button color/off inputs
    // `data` may be legacy format (string) or normalized objects { state: "on"|"off", color: "#hex" }.
    function renderButtonInputs(data) {
      const container = document.getElementById('buttonInputs');
      container.innerHTML = '';
      for (let i = 0; i <= 9; i++) {
        const btnKey = `button_${i}`;
        // Normalize incoming value into object with { state, color }
        let value = data[btnKey];
        let state = "off";
        let color = DEFAULT_BUTTON_COLORS[i];
        if (typeof value === "string") {
          if (value !== "off") {
            state = "on";
            color = value;
          } else {
            state = "off";
          }
        } else if (value && typeof value === "object") {
          state = value.state === "on" ? "on" : "off";
          color = value.color || DEFAULT_BUTTON_COLORS[i];
        }
        const inactive = (state === 'off');
        // store color in data-color so we preserve it even while off
        container.innerHTML += `
          <div style="display:inline-block; margin:0 6px; text-align:center;">
            <div id="${btnKey}_swatch" class="swatch ${inactive ? 'inactive' : ''}" title="Click to toggle on/off"
                 data-color="${color}" style="${inactive ? '' : 'background:' + color}">
            </div>
          </div>
        `;
      }

      // Add event listeners: left-click -> toggle active/inactive
      for (let i = 0; i <= 9; i++) {
        const btnKey = `button_${i}`;
        const swatch = document.getElementById(btnKey + '_swatch');
        if (!swatch) continue;
        swatch.addEventListener('click', function(e) {
          // Toggle on/off
          swatch.classList.toggle('inactive');
          // If activated and no explicit background, apply stored color
          if (!swatch.classList.contains('inactive')) {
            swatch.style.background = swatch.dataset.color || '#ffffff';
          } else {
            // clear background when turned off to show the hatch pattern
            swatch.style.background = '';
          }
          autoSaveAndGenerate();
        });
      }
    }

    // Fill form with data.json values. Normalize legacy button fields to {state,color} and persist back.
    async function fillForm() {
      const raw = await loadJSON('data.json');
      const data = Object.assign({}, raw || {});
      // Ensure knob/slider/switch/canvas fields exist
      document.getElementById('knob_down').value = data.knob_down || 1;
      document.getElementById('zoomValue').textContent = data.knob_down || 1;
      document.getElementById('slider').value = data.slider || 0;
      document.getElementById('sliderValue').textContent = data.slider || 0;
      if (data.switch === 'left') document.getElementById('switch_left').checked = true;
      else if (data.switch === 'right') document.getElementById('switch_right').checked = true;
      else document.getElementById('switch_center').checked = true;
      document.getElementById('canvas_width').value = data.canvas_width || 500;
      document.getElementById('canvas_height').value = data.canvas_height || 500;

      // Normalize button fields into objects { state, color } so colors are never lost.
      let normalized = false;
      for (let i = 0; i <= 9; i++) {
        const key = `button_${i}`;
        const val = data[key];
        if (typeof val === "string") {
          // legacy: either color or "off"
          if (val === "off") {
            data[key] = { state: "off", color: DEFAULT_BUTTON_COLORS[i] };
          } else {
            data[key] = { state: "on", color: val };
          }
          normalized = true;
        } else if (!val || typeof val !== "object") {
          // missing -> initialize default as on with default color
          data[key] = { state: "on", color: DEFAULT_BUTTON_COLORS[i] };
          normalized = true;
        } else {
          // object: ensure fallback color exists
          data[key].color = data[key].color || DEFAULT_BUTTON_COLORS[i];
        }
      }

      // Render UI with normalized data
      renderButtonInputs(data);

      // If we changed structure, persist normalized data back without triggering immediate generation
      if (normalized) {
        try {
          await postJSON('/data.json', data);
        } catch (e) {
          // ignore save error; UI still usable
          console.warn('Failed to persist normalized data', e);
        }
      }
    }

    // Update zoom slider value display
    document.getElementById('knob_down').oninput = function() {
      document.getElementById('zoomValue').textContent = this.value;
    };

    // Update slider value display
    document.getElementById('slider').oninput = function() {
      document.getElementById('sliderValue').textContent = this.value;
    };

    // Save form to data.json and generate new pattern (immediate)
    // Now stores button fields as objects { state: "on"|"off", color: "#hex" } so color is preserved even while off.
    async function autoSaveAndGenerate() {
      const data = {};
      data.knob_down = parseInt(document.getElementById('knob_down').value);
      data.slider = parseInt(document.getElementById('slider').value);
      data.switch = document.querySelector('input[name="switch"]:checked').value;
      data.canvas_width = parseInt(document.getElementById('canvas_width').value);
      data.canvas_height = parseInt(document.getElementById('canvas_height').value);
      for (let i = 0; i <= 9; i++) {
        const btnKey = `button_${i}`;
        const swatch = document.getElementById(btnKey + '_swatch');
        const color = (swatch && swatch.dataset && swatch.dataset.color) ? swatch.dataset.color : DEFAULT_BUTTON_COLORS[i];
        const state = (swatch && !swatch.classList.contains('inactive')) ? "on" : "off";
        data[btnKey] = { state: state, color: color };
      }
      await postJSON('/data.json', data);
      await generateAndSaveHistory();
    }

    // Attach auto-save to all inputs in the form
    function attachAutoSave() {
      const form = document.getElementById('settingsForm');
      form.querySelectorAll('input').forEach(input => {
        input.oninput = autoSaveAndGenerate;
        input.onchange = autoSaveAndGenerate;
      });
    }

    // Drawing logic (unchanged)
    function resolveColor(c) {
      if (!c) return "#000";
      return c;
    }

    function drawTile(ctx, tile, x, y, size) {
      ctx.save();
      ctx.translate(x + size/2, y + size/2);
      ctx.rotate((tile.rotation || 0) * Math.PI / 180);
      ctx.translate(-size/2, -size/2);

      // Background
      ctx.fillStyle = resolveColor(tile.color_fundo);
      ctx.fillRect(0, 0, size, size);

      if (tile.tile === "Padrao Quadrado") {
        ctx.fillStyle = resolveColor(tile.color_padrao);
        ctx.fillRect(0, 0, size/2, size);
      } else if (tile.tile === "Padrao Triangulos") {
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(size, 0);
        ctx.lineTo(0, size);
        ctx.closePath();
        ctx.fillStyle = resolveColor(tile.color_padrao);
        ctx.fill();
      }
      ctx.restore();
    }

    const TILE_MARGIN_RATIO = 0.008; // 8% of tile size as margin

    // Helper: detect max safe canvas dimension (uses WebGL MAX_TEXTURE_SIZE) and ensure requested canvas fits
    function getMaxCanvasSize() {
      try {
        const probe = document.createElement('canvas');
        const gl = probe.getContext('webgl') || probe.getContext('experimental-webgl');
        if (!gl) return 4096;
        const max = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        return (typeof max === 'number' && max > 0) ? max : 4096;
      } catch (e) {
        return 4096;
      }
    }
    function ensureCanvasSizeWithinLimits(reqW, reqH) {
      const maxDim = getMaxCanvasSize();
      if (reqW <= maxDim && reqH <= maxDim) return { width: reqW, height: reqH, scale: 1 };
      const scale = Math.min(maxDim / reqW, maxDim / reqH);
      const newW = Math.max(1, Math.floor(reqW * scale));
      const newH = Math.max(1, Math.floor(reqH * scale));
      return { width: newW, height: newH, scale: scale };
    }

    // Helper: keep large intrinsic canvas but scale the displayed size to fit the screen
    function applyCanvasDisplaySize(canvas, intrinsicW, intrinsicH) {
      // how much of the viewport we allow the canvas to use
      const maxViewportWidth = window.innerWidth * 0.95;  // 95% of viewport width
      const maxViewportHeight = window.innerHeight * 0.8; // 80% of viewport height (leave room for header/buttons)
      const scale = Math.min(maxViewportWidth / intrinsicW, maxViewportHeight / intrinsicH, 1);
      canvas.style.width = Math.round(intrinsicW * scale) + 'px';
      canvas.style.height = Math.round(intrinsicH * scale) + 'px';
      // store intrinsic size so resize handler can reapply scale
      canvas.dataset.intrinsicWidth = intrinsicW;
      canvas.dataset.intrinsicHeight = intrinsicH;
      canvas.dataset.displayScale = scale;
    }

    async function drawPattern() {
      const pattern = await loadJSON('pattern.json');
      const data = await loadJSON('data.json');
      const canvas = document.getElementById('patternCanvas');
      const width = data.canvas_width || 500;
      const height = data.canvas_height || 500;

      // Ensure backing buffer fits browser/GPU limits. If needed downscale internal buffer but keep
      // the original requested intrinsic size for display (CSS) so UI remains consistent.
      const adjusted = ensureCanvasSizeWithinLimits(width, height);
      if (adjusted.scale !== 1) {
        console.warn('Requested canvas size exceeds browser limits; drawing buffer downscaled by', adjusted.scale.toFixed(3));
      }
      // set the actual drawing buffer (may be downscaled)
      canvas.width = adjusted.width;
      canvas.height = adjusted.height;
      // apply display size using original requested intrinsic size so the canvas appears at expected dimensions
      applyCanvasDisplaySize(canvas, width, height);

      let maxX = 0, maxY = 0;
      pattern.forEach(tile => {
        if (tile.grid_x > maxX) maxX = tile.grid_x;
        if (tile.grid_y > maxY) maxY = tile.grid_y;
      });
      // When backing buffer was downscaled, we must scale drawing coordinates to match.
      const drawScaleX = adjusted.width / width;
      const drawScaleY = adjusted.height / height;
      const cols = Math.max(1, maxX);
      const rows = Math.max(1, maxY);
      const tileSize = Math.min(width / cols, height / rows);
      const margin = tileSize * TILE_MARGIN_RATIO;
      const drawSize = tileSize - margin;
      const offsetX = (width - tileSize * cols) / 2;
      const offsetY = (height - tileSize * rows) / 2;

      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, width, height);

      // Fill background with white for margins
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, adjusted.width, adjusted.height);

      pattern.forEach(tile => {
        // map display coordinates into backing-buffer coordinates if downscaled
        const x_disp = offsetX + (tile.grid_x - 1) * tileSize + margin / 2;
        const y_disp = offsetY + (tile.grid_y - 1) * tileSize + margin / 2;
        const x = x_disp * drawScaleX;
        const y = y_disp * drawScaleY;
        const size = drawSize * Math.min(drawScaleX, drawScaleY);
        drawTile(ctx, tile, x, y, size);
      });
    }

    // Pattern history management
    let patternHistory = [];
    let historyIndex = -1;
    let debounceTimer = null;

    function patternsAreEqual(a, b) {
      return JSON.stringify(a) === JSON.stringify(b);
    }

    function loadHistory() {
      const hist = localStorage.getItem('patternHistory');
      if (hist) {
        patternHistory = JSON.parse(hist);
        // support legacy entries that were only arrays
        patternHistory = patternHistory.map(e => {
          if (Array.isArray(e)) return { pattern: e, data: null };
          return e;
        });
        historyIndex = parseInt(localStorage.getItem('historyIndex')) || (patternHistory.length - 1);
      }
      updateHistoryButtons();
    }
    
    function saveHistory() {
      // helper to identify quota errors across browsers
      function isQuotaExceeded(err) {
        if (!err) return false;
        return err.name === 'QuotaExceededError' || err.name === 'NS_ERROR_DOM_QUOTA_REACHED' ||
               err.code === 22 || err.code === 1014;
      }

      // Try to persist; on quota error evict oldest entries until it fits.
      try {
        localStorage.setItem('patternHistory', JSON.stringify(patternHistory));
      } catch (e) {
        if (isQuotaExceeded(e)) {
          // Keep removing oldest entries until it fits (or until only current entry left)
          // Note: we attempt to preserve the most recent history at the end of the array.
          while (patternHistory.length > 1) {
            patternHistory.shift(); // evict oldest
            try {
              localStorage.setItem('patternHistory', JSON.stringify(patternHistory));
              break; // saved successfully
            } catch (err) {
              if (!isQuotaExceeded(err)) {
                // unknown error, rethrow
                throw err;
              }
              // still quota exceeded -> continue evicting
            }
          }
          // If we still can't save (very large single entry), fall back to empty history
          if (patternHistory.length <= 1) {
            try {
              localStorage.setItem('patternHistory', JSON.stringify([]));
              historyIndex = -1;
            } catch (err) {
              // give up silently; nothing more we can do in localStorage
              console.warn('saveHistory: unable to persist even minimal history', err);
            }
          }
        } else {
          // not a quota problem -> rethrow so it surfaces
          throw e;
        }
      }

      // Try to persist historyIndex (best-effort)
      try {
        localStorage.setItem('historyIndex', historyIndex);
      } catch (e) {
        // ignore failures here (historyIndex is small)
        console.warn('saveHistory: failed to save historyIndex', e);
      }

      updateHistoryButtons();
    }
    
    function updateHistoryButtons() {
      document.getElementById('backBtn').disabled = historyIndex <= 0;
      document.getElementById('forwardBtn').disabled = historyIndex >= patternHistory.length - 1;
    }
    
    async function fetchCurrentPattern() {
      return await loadJSON('pattern.json');
    }
    
    async function drawPatternFromHistory(idx) {
      if (patternHistory[idx]) {
        const entry = patternHistory[idx];
        const pattern = entry.pattern || entry; // support legacy
        // prefer saved data that matches this pattern; fallback to current data.json
        let data = entry.data;
        if (!data) {
          data = await loadJSON('data.json');
        }
        const canvas = document.getElementById('patternCanvas');
        const width = data.canvas_width || 500;
        const height = data.canvas_height || 500;

        const adjusted = ensureCanvasSizeWithinLimits(width, height);
        if (adjusted.scale !== 1) {
          console.warn('Requested canvas size exceeds browser limits; drawing buffer downscaled by', adjusted.scale.toFixed(3));
        }
        canvas.width = adjusted.width;
        canvas.height = adjusted.height;
        applyCanvasDisplaySize(canvas, width, height);

        const drawScaleX = adjusted.width / width;
        const drawScaleY = adjusted.height / height;
        let maxX = 0, maxY = 0;
         pattern.forEach(tile => {
           if (tile.grid_x > maxX) maxX = tile.grid_x;
           if (tile.grid_y > maxY) maxY = tile.grid_y;
         });
         const cols = Math.max(1, maxX);
         const rows = Math.max(1, maxY);
         const tileSize = Math.min(width / cols, height / rows);
         const margin = tileSize * TILE_MARGIN_RATIO;
         const drawSize = tileSize - margin;
         const offsetX = (width - tileSize * cols) / 2;
         const offsetY = (height - tileSize * rows) / 2;
 
         const ctx = canvas.getContext('2d');

         ctx.clearRect(0, 0, adjusted.width, adjusted.height);
 
         // Fill background with white for margins
         ctx.fillStyle = "#fff";
         ctx.fillRect(0, 0, adjusted.width, adjusted.height);
 
         pattern.forEach(tile => {
           const x_disp = offsetX + (tile.grid_x - 1) * tileSize + margin / 2;
           const y_disp = offsetY + (tile.grid_y - 1) * tileSize + margin / 2;
           const x = x_disp * drawScaleX;
           const y = y_disp * drawScaleY;
           const size = drawSize * Math.min(drawScaleX, drawScaleY);
           drawTile(ctx, tile, x, y, size);
         });
       }
       updateHistoryButtons();
     }
 
     // On new generation, always append to end of history (never erase forward)
     async function generateAndSaveHistory() {
       // POST to /generate must include credentials so cookie (mirrored from localStorage) is sent
       await fetch('/generate', { method: 'POST', credentials: 'same-origin' });
       setTimeout(async () => {
         const pattern = await fetchCurrentPattern();
         const data = await loadJSON('data.json'); // capture the data that produced this pattern
         // Always append new pattern+data to end of history
         patternHistory.push({ pattern: pattern, data: data });
         // Limit history to 100 generations
         if (patternHistory.length > 100) {
           patternHistory = patternHistory.slice(patternHistory.length - 100);
         }
         historyIndex = patternHistory.length - 1;
         saveHistory();
         drawPatternFromHistory(historyIndex);
       }, 300);
     }

    document.getElementById('generateBtn').onclick = generateAndSaveHistory;

    document.getElementById('backBtn').onclick = function() {
      if (historyIndex > 0) {
        historyIndex--;
        saveHistory();
        drawPatternFromHistory(historyIndex);
      }
    };

    document.getElementById('forwardBtn').onclick = function() {
      if (historyIndex < patternHistory.length - 1) {
        historyIndex++;
        saveHistory();
        drawPatternFromHistory(historyIndex);
      }
    };

    // Debounced auto-save and generate
    async function autoSaveAndGenerate() {
      const data = {};
      data.knob_down = parseInt(document.getElementById('knob_down').value);
      data.slider = parseInt(document.getElementById('slider').value);
      data.switch = document.querySelector('input[name="switch"]:checked').value;
      data.canvas_width = parseInt(document.getElementById('canvas_width').value);
      data.canvas_height = parseInt(document.getElementById('canvas_height').value);
      for (let i = 0; i <= 9; i++) {
        const btnKey = `button_${i}`;
        const swatch = document.getElementById(btnKey + '_swatch');
        const color = (swatch && swatch.dataset && swatch.dataset.color) ? swatch.dataset.color : DEFAULT_BUTTON_COLORS[i];
        const state = (swatch && !swatch.classList.contains('inactive')) ? "on" : "off";
        data[btnKey] = { state: state, color: color };
      }
      await postJSON('/data.json', data);

      // Debounce pattern generation
      if (debounceTimer) clearTimeout(debounceTimer);
      debounceTimer = setTimeout(generateAndSaveHistory, 400);
    }

    // Overlay logic
    const settingsOverlay = document.getElementById('settingsOverlay');
    const showSettingsTab = document.getElementById('showSettingsTab');
    const closeSettingsBtn = document.getElementById('closeSettingsBtn');
    const settingsPanel = document.getElementById('settingsPanel');

    showSettingsTab.onclick = function() {
      settingsOverlay.style.display = 'flex';
      showSettingsTab.style.display = 'none';
    };
    closeSettingsBtn.onclick = function() {
      settingsOverlay.style.display = 'none';
      showSettingsTab.style.display = 'flex';
    };
    // Click outside panel closes overlay
    settingsOverlay.onclick = function(e) {
      if (e.target === settingsOverlay) {
        settingsOverlay.style.display = 'none';
        showSettingsTab.style.display = 'flex';
      }
    };

    // Initial load
    // Ensure session cookie mirrors localStorage on every load before requests start
    ensureSessionId();
    fillForm().then(attachAutoSave);
    loadHistory();
    // If history exists, draw last pattern, else draw current
    if (patternHistory.length > 0) {
      drawPatternFromHistory(historyIndex);
    } else {
      drawPattern();
    }

    // Generate drawing instructions from a pattern array
    function getDrawingInstructions(pattern) {
      let instructions = [];
      pattern.forEach((tile, idx) => {
        instructions.push(
          `Tile ${idx + 1}: Type=${tile.tile}, Grid=(${tile.grid_x},${tile.grid_y}), Rotation=${tile.rotation || 0}, ` +
          `Background=${tile.color_fundo}, PatternColor=${tile.color_padrao}`
        );
      });
      return instructions.join('\n');
    }

    // Print button logic
    document.getElementById('printBtn').onclick = function() {
      const entry = patternHistory[historyIndex];
      if (!entry) return;
      // entry may be { pattern, data } or legacy pattern array
      const pattern = entry.pattern || entry;
      const instructions = getDrawingInstructions(pattern);
      const blob = new Blob([instructions], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `pepe_pattern_instructions.txt`;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    };

    // Keep displayed canvas scaled properly when the window resizes
    window.addEventListener('resize', () => {
      const canvas = document.getElementById('patternCanvas');
      const iw = parseInt(canvas.dataset.intrinsicWidth || 0, 10);
      const ih = parseInt(canvas.dataset.intrinsicHeight || 0, 10);
      if (iw && ih) applyCanvasDisplaySize(canvas, iw, ih);
    });
  </script>
</body>
</html>