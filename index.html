<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=BBH+Sans+Hegarty&family=Offside&family=Rajdhani:wght@300;400;500;600;700&family=Silkscreen:wght@400;700&display=swap" rel="stylesheet">
  <title>PepesMachine</title>
  <style>
    /* Keep the entire page fixed to the viewport and never show document scrollbars */
    html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; background: #ffffff; color: #210e99; }
    /* swatch styles for color icons (active/inactive) */
    .swatch {
      width: 30px;
      height: 30px;
      border-radius: 6px;
      border: 2px transparent solid;
      display: inline-block;
      cursor: pointer;
      vertical-align: middle;
      box-sizing: border-box;
    }
    h1 { 
      margin-top: 20px;
      font-family: "Rajdhani", sans-serif;
      font-size: 2vw;
      font-style: bold;
    }
    .swatch.inactive {
      background: repeating-linear-gradient(45deg,#ddd,#ddd 6px,#fff 6px,#fff 12px);
      opacity: 0.8;
      border-color: #444;
    }
    /* Main container fills the viewport. It contains a scrollable pattern area so the
       overall document never scrolls while the canvas may be panned internally. */
    #mainCanvasContainer {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: flex-start;
      height: 100vh;
      width: 100vw;
      box-sizing: border-box;
      padding: 0 8px; /* small horizontal padding so things don't hug the edges */
      min-height: 0; /* allow children to use flex properly */
    }

    /* Area that holds the canvas. We keep overflow hidden so the page never shows scrollbars.
       The canvas will be scaled via CSS to always fit this area. */
    #patternArea {
      flex: 1 1 auto;
      display: flex;
      align-items: center;
      margin-bottom: 3vh;
      justify-content: center;
      overflow: hidden; /* never show scrollbars */
      -webkit-overflow-scrolling: touch;
      min-height: 0; /* allow flex child to shrink properly */
    }

    /* Canvas styling: remove large margins that could cause document overflow */
    canvas { background: #fff; display: block; box-shadow: 0 2px 16px #0006; max-width: none; max-height: none; }

    /* Controls bar: fixed to the viewport bottom so it never disappears.
       It sits above the pattern area and has a translucent background. */
    #controls {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      padding: 8px 12px;
      background: linear-gradient(to top, rgba(255,255,255,0.95), rgba(255,255,255,0.6));
      box-shadow: 0 -6px 18px rgba(0,0,0,0.12);
      z-index: 300; /* above canvas but below modals/overlays which use higher z */
      backdrop-filter: blur(4px);
      transition: transform 280ms ease, opacity 200ms ease;
      transform: translateY(0);
    }
    /* hidden state moves the controls off-screen */
    #controls.hidden { transform: translateY(100%); opacity: 0; }
    #controls.visible { transform: translateY(0); opacity: 1; }

    /* small draggable handle that appears when controls are hidden */
    #controlsHandle {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 8px;
      width: 64px;
      height: 18px;
      border-radius: 12px;
      background: rgba(0,0,0,0.06);
      box-shadow: 0 2px 6px rgba(0,0,0,0.12);
      z-index: 1200;
      cursor: pointer;
      opacity: 0;
      transition: opacity 180ms ease;
      pointer-events: none;
    }
    #controls .btn-row { display:flex; gap:8px; align-items:center; }

    /* Ensure patternArea content doesn't get hidden by the fixed controls: add bottom inset */
  /* small fallback padding in case JS doesn't run; actual reserved space is computed dynamically */
  #patternArea { padding-bottom: 12px; }

    @media (min-width: 900px) {
      /* On wide screens, show controls inline (not necessarily fixed) ‚Äî keep small constant bar */
      #controls { max-width: 900px; margin: 0 auto; }
    }
    #settingsOverlay {
      position: fixed;
      top: 0; left: 0; width: 100vw; height: 100vh;
      background: #222e;
      display: none;
      z-index: 1000;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    #settingsPanel {
      background: #333;
      padding: 30px 20px 20px 20px;
      border-radius: 16px;
      box-shadow: 0 4px 32px #000a;
      max-width: 440px;
      width: 90vw;
      max-height: 90vh;
      overflow-y: auto;
      position: relative;
      margin: auto;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #showSettingsTab {
      position: fixed;
      top: 40px;
      right: 0;
      background: #4caf50;
      color: #fff;
      border-radius: 8px 0 0 8px;
      padding: 12px 24px 12px 12px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      z-index: 101;
      box-shadow: -2px 2px 10px #0006;
      transition: background 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #showSettingsTab:hover {
      background: #388e3c;
    }
    #closeSettingsBtn {
      position: absolute;
      top: 12px;
      left: 12px;
      background: #222;
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 6px 14px;
      font-size: 1em;
      cursor: pointer;
      box-shadow: 0 2px 8px #0004;
      transition: background 0.2s;
    }
    #closeSettingsBtn:hover {
      background: #444;
    }
    .form-section {
      margin: 0 auto;
      background: #333;
      padding: 0;
      border-radius: 10px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 16px;
      align-items: center;
    }
    .form-row {
      display: flex;
      align-items: center;
      width: 100%;
      justify-content: center;
      gap: 10px;
    }
    .form-section label {
      min-width: 110px;
      text-align: right;
      margin-right: 10px;
      flex-shrink: 0;
    }
    .form-section input[type="number"] { width: 60px; }
    .form-section input[type="color"] { width: 40px; height: 30px; vertical-align: middle; }
    .form-section input[type="range"] { width: 120px; }
    .button-row label { min-width: 80px; text-align: right; }
    .off-label { margin-left: 10px; }
    .switch-group {
      display: flex;
      gap: 8px;
      margin-left: 5px;
    }
    .switch-radio {
      appearance: none;
      width: 22px;
      height: 22px;
      border: 2px solid #888;
      border-radius: 50%;
      background: #222;
      cursor: pointer;
      transition: border-color 0.2s, box-shadow 0.2s;
      position: relative;
    }
    .switch-radio:checked {
      border-color: #4caf50;
      box-shadow: 0 0 0 2px #4caf5055;
      background: #4caf50;
    }
    .button-row {
      display: flex;
      align-items: center;
      width: 100%;
      justify-content: center;
      gap: 10px;
    }
    #buttonInputs > div {
      display: inline-block;
      margin: 0 2px;
      vertical-align: middle;
    }
    @media (max-width: 600px) {
      #settingsPanel {
        max-width: 98vw;
        padding: 18px 2vw 10px 2vw;
      }
      .form-section label { min-width: 80px; font-size: 0.95em; }
      #showSettingsTab { font-size: 1em; padding: 10px 18px 10px 8px; }
    }
    /* Potentiometer styles (fixed on right) */
    #potentiometer {
      position: fixed;
      right: 18px;
      top: 20%;
      transform: translateY(-50%);
      width: 96px;
      height: 96px;
      z-index: 1100;
      cursor: pointer;
      user-select: none;
      touch-action: none;
    }
    #potentiometer img { position: absolute; left: 0; top: 0; width: 100%; height: 100%; pointer-events: none; }
  #potentiometer #pot_front { transform-origin: 50% 50%; transition: transform 120ms linear; transform: translate(25%,25%) scale(0.5); }
    /* Hide the settings knob input visually but keep it in the DOM for accessibility */
    #settingsForm input[type="range"]#knob_down { position: absolute; left: -9999px; width: 1px; height: 1px; opacity: 0; }
  </style>
</head>
<body>
    <div id="mainCanvasContainer">
  <!-- Replaced textual title with logo image from static/Nome.png -->
  <!-- Logo image served from ./static/Nome.png -> available at /static/Nome.png -->
  <img id="logo" src="/static/Nome.png" alt="PEPESMACHINE" style="max-width:60vw; height:auto; display:block; margin:18px auto;">
  <!-- Potentiometer control (fixed on right) -->
  <div id="potentiometer" aria-hidden="false" title="Zoom">
    <img id="pot_back" src="/static/button_zoom_back.png" alt="pot-back">
    <img id="pot_front" src="/static/button_zoom_front.png" alt="pot-front">
    <div id="pot_value" aria-hidden="true" style="display:none"></div>
  </div>
    <div id="patternArea">
      <canvas id="patternCanvas"></canvas>
    </div>
    <div id="controls">
      <div class="btn-row"><button id="generateBtn">Generate New Pattern</button></div>
      <div class="btn-row">
        <button id="backBtn" disabled>&#8592; Go Back</button>
        <button id="forwardBtn" disabled>Go Forward &#8594;</button>
        <button id="printBtn">üñ®Ô∏è Print Instructions</button>
      </div>
    </div>
    <!-- Small handle to reveal hidden controls on mobile -->
    <div id="controlsHandle" title="Show controls" aria-hidden="true"></div>
  </div>
  <div id="showSettingsTab">
    <span style="font-size:1.3em;">&#9654;</span> PepesMachine
  </div>
  <div id="settingsOverlay">
    <div id="settingsPanel">
      <button id="closeSettingsBtn">&#8592; Back to Canvas</button>
      <form id="settingsForm" class="form-section">
        <div class="form-row">
          <label for="knob_down">Zoom:</label>
          <input type="range" id="knob_down" name="knob_down" min="1" max="10" step="1">
          <span id="zoomValue"></span>
        </div>
        <div class="form-row">
          <label for="slider">Slider:</label>
          <input type="range" id="slider" name="slider" min="0" max="100">
          <span id="sliderValue"></span>
        </div>
        <div class="form-row">
          <label>Switch:</label>
          <span class="switch-group">
            <input type="radio" id="switch_left" class="switch-radio" name="switch" value="left">
            <input type="radio" id="switch_center" class="switch-radio" name="switch" value="center">
            <input type="radio" id="switch_right" class="switch-radio" name="switch" value="right">
          </span>
        </div>
        <div class="form-row">
          <label for="canvas_width">Canvas Width:</label>
          <input type="number" id="canvas_width" name="canvas_width" min="10" max="1000000" required>
        </div>
        <div class="form-row">
          <label for="canvas_height">Canvas Height:</label>
          <input type="number" id="canvas_height" name="canvas_height" min="10" max="1000000" required>
        </div>
        <div class="button-row">
          <label>Buttons:</label>
          <div>
            <span id="buttonInputs"></span>
          </div>
        </div>
        <!-- Removed the Save Settings button -->
      </form>
    </div>
  </div>
  <script>
    // Default button colors (will be used as fallback and initial palette)
    const DEFAULT_BUTTON_COLORS = [
      "#ff66de","#f98686","#7081ff","#62fe74","#fcff4d",
      "#ff7b24","#bd7ef1","#ffffff","#007EA7","#3517ab"
    ];

    // Persist session id via localStorage (survives browser restarts).
    // We still set a cookie from localStorage so fetch requests include it.
    function ensureSessionId() {
      let sid = localStorage.getItem('session_id');
      if (!sid) {
        sid = (crypto && crypto.randomUUID) ? crypto.randomUUID() : ('s' + Date.now() + '-' + Math.random().toString(36).slice(2,10));
        localStorage.setItem('session_id', sid);
      }
      // Mirror into a cookie so server request handlers can read it
      // Cookie is intentionally session-length (no expires) but is overwritten on load from localStorage.
      document.cookie = 'session_id=' + encodeURIComponent(sid) + '; path=/';
    }
    ensureSessionId();

    // Helper to load JSON
    async function loadJSON(url) {
      const resp = await fetch(url, { credentials: 'same-origin' });
      return await resp.json();
    }

    // Helper to POST JSON
    async function postJSON(url, data) {
      await fetch(url, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(data),
        credentials: 'same-origin'
      });
    }

    // Dynamically create button color/off inputs
    // `data` may be legacy format (string) or normalized objects { state: "on"|"off", color: "#hex" }.
    function renderButtonInputs(data) {
      const container = document.getElementById('buttonInputs');
      container.innerHTML = '';
      for (let i = 0; i <= 9; i++) {
        const btnKey = `button_${i}`;
        // Normalize incoming value into object with { state, color }
        let value = data[btnKey];
        let state = "off";
        let color = DEFAULT_BUTTON_COLORS[i];
        if (typeof value === "string") {
          if (value !== "off") {
            state = "on";
            color = value;
          } else {
            state = "off";
          }
        } else if (value && typeof value === "object") {
          state = value.state === "on" ? "on" : "off";
          color = value.color || DEFAULT_BUTTON_COLORS[i];
        }
        const inactive = (state === 'off');
        // store color in data-color so we preserve it even while off
        container.innerHTML += `
          <div style="display:inline-block; margin:0 6px; text-align:center;">
            <div id="${btnKey}_swatch" class="swatch ${inactive ? 'inactive' : ''}" title="Click to toggle on/off"
                 data-color="${color}" style="${inactive ? '' : 'background:' + color}">
            </div>
          </div>
        `;
      }

      // Add event listeners: left-click -> toggle active/inactive
      for (let i = 0; i <= 9; i++) {
        const btnKey = `button_${i}`;
        const swatch = document.getElementById(btnKey + '_swatch');
        if (!swatch) continue;
        swatch.addEventListener('click', function(e) {
          // Toggle on/off
          swatch.classList.toggle('inactive');
          // If activated and no explicit background, apply stored color
          if (!swatch.classList.contains('inactive')) {
            swatch.style.background = swatch.dataset.color || '#ffffff';
          } else {
            // clear background when turned off to show the hatch pattern
            swatch.style.background = '';
          }
          autoSaveAndGenerate();
        });
      }
    }

    // Fill form with data.json values. Normalize legacy button fields to {state,color} and persist back.
    async function fillForm() {
      const raw = await loadJSON('data.json');
      const data = Object.assign({}, raw || {});
      // Ensure knob/slider/switch/canvas fields exist
      document.getElementById('knob_down').value = data.knob_down || 1;
      document.getElementById('zoomValue').textContent = data.knob_down || 1;
      document.getElementById('slider').value = data.slider || 0;
      document.getElementById('sliderValue').textContent = data.slider || 0;
      if (data.switch === 'left') document.getElementById('switch_left').checked = true;
      else if (data.switch === 'right') document.getElementById('switch_right').checked = true;
      else document.getElementById('switch_center').checked = true;
      document.getElementById('canvas_width').value = data.canvas_width || 500;
      document.getElementById('canvas_height').value = data.canvas_height || 500;

      // Normalize button fields into objects { state, color } so colors are never lost.
      let normalized = false;
      for (let i = 0; i <= 9; i++) {
        const key = `button_${i}`;
        const val = data[key];
        if (typeof val === "string") {
          // legacy: either color or "off"
          if (val === "off") {
            data[key] = { state: "off", color: DEFAULT_BUTTON_COLORS[i] };
          } else {
            data[key] = { state: "on", color: val };
          }
          normalized = true;
        } else if (!val || typeof val !== "object") {
          // missing -> initialize default as on with default color
          data[key] = { state: "on", color: DEFAULT_BUTTON_COLORS[i] };
          normalized = true;
        } else {
          // object: ensure fallback color exists
          data[key].color = data[key].color || DEFAULT_BUTTON_COLORS[i];
        }
      }

      // Render UI with normalized data
      renderButtonInputs(data);

      // If we changed structure, persist normalized data back without triggering immediate generation
      if (normalized) {
        try {
          await postJSON('/data.json', data);
        } catch (e) {
          // ignore save error; UI still usable
          console.warn('Failed to persist normalized data', e);
        }
      }
    }

    // Update zoom slider value display
    document.getElementById('knob_down').oninput = function() {
      document.getElementById('zoomValue').textContent = this.value;
    };

    // Update slider value display
    document.getElementById('slider').oninput = function() {
      document.getElementById('sliderValue').textContent = this.value;
    };

    // Save form to data.json and generate new pattern (immediate)
    // Now stores button fields as objects { state: "on"|"off", color: "#hex" } so color is preserved even while off.
    async function autoSaveAndGenerate() {
      const data = {};
      data.knob_down = parseInt(document.getElementById('knob_down').value);
      data.slider = parseInt(document.getElementById('slider').value);
      data.switch = document.querySelector('input[name="switch"]:checked').value;
      data.canvas_width = parseInt(document.getElementById('canvas_width').value);
      data.canvas_height = parseInt(document.getElementById('canvas_height').value);
      for (let i = 0; i <= 9; i++) {
        const btnKey = `button_${i}`;
        const swatch = document.getElementById(btnKey + '_swatch');
        const color = (swatch && swatch.dataset && swatch.dataset.color) ? swatch.dataset.color : DEFAULT_BUTTON_COLORS[i];
        const state = (swatch && !swatch.classList.contains('inactive')) ? "on" : "off";
        data[btnKey] = { state: state, color: color };
      }
      await postJSON('/data.json', data);
      await generateAndSaveHistory();
    }

    // Attach auto-save to all inputs in the form
    function attachAutoSave() {
      const form = document.getElementById('settingsForm');
      form.querySelectorAll('input').forEach(input => {
        input.oninput = autoSaveAndGenerate;
        input.onchange = autoSaveAndGenerate;
      });
    }

    // Drawing logic (unchanged)
    function resolveColor(c) {
      if (!c) return "#000";
      return c;
    }

    function drawTile(ctx, tile, x, y, size) {
      ctx.save();
      ctx.translate(x + size/2, y + size/2);
      ctx.rotate((tile.rotation || 0) * Math.PI / 180);
      ctx.translate(-size/2, -size/2);

      // Background
      ctx.fillStyle = resolveColor(tile.color_fundo);
      ctx.fillRect(0, 0, size, size);

      if (tile.tile === "Padrao Quadrado") {
        ctx.fillStyle = resolveColor(tile.color_padrao);
        ctx.fillRect(0, 0, size/2, size);
      } else if (tile.tile === "Padrao Triangulos") {
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(size, 0);
        ctx.lineTo(0, size);
        ctx.closePath();
        ctx.fillStyle = resolveColor(tile.color_padrao);
        ctx.fill();
      }
      ctx.restore();
    }

    const TILE_MARGIN_RATIO = 0.008; // 8% of tile size as margin

    // Helper: detect max safe canvas dimension (uses WebGL MAX_TEXTURE_SIZE) and ensure requested canvas fits
    function getMaxCanvasSize() {
      try {
        const probe = document.createElement('canvas');
        const gl = probe.getContext('webgl') || probe.getContext('experimental-webgl');
        if (!gl) return 4096;
        const max = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        return (typeof max === 'number' && max > 0) ? max : 4096;
      } catch (e) {
        return 4096;
      }
    }
    function ensureCanvasSizeWithinLimits(reqW, reqH) {
      const maxDim = getMaxCanvasSize();
      if (reqW <= maxDim && reqH <= maxDim) return { width: reqW, height: reqH, scale: 1 };
      const scale = Math.min(maxDim / reqW, maxDim / reqH);
      const newW = Math.max(1, Math.floor(reqW * scale));
      const newH = Math.max(1, Math.floor(reqH * scale));
      return { width: newW, height: newH, scale: scale };
    }

    // Helper: keep large intrinsic canvas but scale the displayed size to fit the screen
    function applyCanvasDisplaySize(canvas, intrinsicW, intrinsicH) {
      // how much of the patternArea viewport we allow the canvas to use
      const patternArea = document.getElementById('patternArea');
      const areaRect = patternArea ? patternArea.getBoundingClientRect() : { width: window.innerWidth, height: window.innerHeight };
  // Fit the canvas into the patternArea viewport while preserving aspect ratio.
  const maxViewportWidth = Math.max(1, areaRect.width - 16);  // small padding
  // subtract controls height so canvas doesn't sit beneath fixed controls
  const controlsEl = document.getElementById('controls');
  const controlsRect = controlsEl ? controlsEl.getBoundingClientRect() : { height: 0 };
  const reserved = Math.max(12, Math.round(controlsRect.height));
  const maxViewportHeight = Math.max(1, areaRect.height - reserved - 8);
  const scale = Math.min(maxViewportWidth / intrinsicW, maxViewportHeight / intrinsicH, 1);
  const cssW = Math.round(intrinsicW * scale);
  const cssH = Math.round(intrinsicH * scale);
  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  // ensure the canvas doesn't exceed the area (safety)
  canvas.style.maxWidth = Math.round(maxViewportWidth) + 'px';
  canvas.style.maxHeight = Math.round(maxViewportHeight) + 'px';
      // store intrinsic size so resize handler can reapply scale
      canvas.dataset.intrinsicWidth = intrinsicW;
      canvas.dataset.intrinsicHeight = intrinsicH;
      canvas.dataset.displayScale = scale;
    }

    async function drawPattern() {
      const pattern = await loadJSON('pattern.json');
      const data = await loadJSON('data.json');
      const canvas = document.getElementById('patternCanvas');
      const width = data.canvas_width || 500;
      const height = data.canvas_height || 500;

      // Ensure backing buffer fits browser/GPU limits. If needed downscale internal buffer but keep
      // the original requested intrinsic size for display (CSS) so UI remains consistent.
      const adjusted = ensureCanvasSizeWithinLimits(width, height);
      if (adjusted.scale !== 1) {
        console.warn('Requested canvas size exceeds browser limits; drawing buffer downscaled by', adjusted.scale.toFixed(3));
      }
      // set the actual drawing buffer (may be downscaled)
      canvas.width = adjusted.width;
      canvas.height = adjusted.height;
      // apply display size using original requested intrinsic size so the canvas appears at expected dimensions
      applyCanvasDisplaySize(canvas, width, height);

      let maxX = 0, maxY = 0;
      pattern.forEach(tile => {
        if (tile.grid_x > maxX) maxX = tile.grid_x;
        if (tile.grid_y > maxY) maxY = tile.grid_y;
      });
      // When backing buffer was downscaled, we must scale drawing coordinates to match.
      const drawScaleX = adjusted.width / width;
      const drawScaleY = adjusted.height / height;
      const cols = Math.max(1, maxX);
      const rows = Math.max(1, maxY);
      const tileSize = Math.min(width / cols, height / rows);
      const margin = tileSize * TILE_MARGIN_RATIO;
      const drawSize = tileSize - margin;
      const offsetX = (width - tileSize * cols) / 2;
      const offsetY = (height - tileSize * rows) / 2;

      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, width, height);

      // Fill background with white for margins
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, adjusted.width, adjusted.height);

      pattern.forEach(tile => {
        // map display coordinates into backing-buffer coordinates if downscaled
        const x_disp = offsetX + (tile.grid_x - 1) * tileSize + margin / 2;
        const y_disp = offsetY + (tile.grid_y - 1) * tileSize + margin / 2;
        const x = x_disp * drawScaleX;
        const y = y_disp * drawScaleY;
        const size = drawSize * Math.min(drawScaleX, drawScaleY);
        drawTile(ctx, tile, x, y, size);
      });
      // After drawing, ensure the canvas CSS is sized to fit the patternArea
      recomputeCanvasSize();
    }

    // Pattern history management
    let patternHistory = [];
    let historyIndex = -1;
    let debounceTimer = null;
  // Flag to indicate a generation is in progress (server processing + waiting for pattern.json)
  let isGenerationInProgress = false;
  // If a generation request arrives while another is in progress, queue one follow-up run
  let needsGenerateAfterCurrent = false;

    function patternsAreEqual(a, b) {
      return JSON.stringify(a) === JSON.stringify(b);
    }

    function loadHistory() {
      const hist = localStorage.getItem('patternHistory');
      if (hist) {
        patternHistory = JSON.parse(hist);
        // support legacy entries that were only arrays
        patternHistory = patternHistory.map(e => {
          if (Array.isArray(e)) return { pattern: e, data: null };
          return e;
        });
        historyIndex = parseInt(localStorage.getItem('historyIndex')) || (patternHistory.length - 1);
      }
      updateHistoryButtons();
    }
    
    function saveHistory() {
      // helper to identify quota errors across browsers
      function isQuotaExceeded(err) {
        if (!err) return false;
        return err.name === 'QuotaExceededError' || err.name === 'NS_ERROR_DOM_QUOTA_REACHED' ||
               err.code === 22 || err.code === 1014;
      }

      // Try to persist; on quota error evict oldest entries until it fits.
      try {
        localStorage.setItem('patternHistory', JSON.stringify(patternHistory));
      } catch (e) {
        if (isQuotaExceeded(e)) {
          // Keep removing oldest entries until it fits (or until only current entry left)
          // Note: we attempt to preserve the most recent history at the end of the array.
          while (patternHistory.length > 1) {
            patternHistory.shift(); // evict oldest
            try {
              localStorage.setItem('patternHistory', JSON.stringify(patternHistory));
              break; // saved successfully
            } catch (err) {
              if (!isQuotaExceeded(err)) {
                // unknown error, rethrow
                throw err;
              }
              // still quota exceeded -> continue evicting
            }
          }
          // If we still can't save (very large single entry), fall back to empty history
          if (patternHistory.length <= 1) {
            try {
              localStorage.setItem('patternHistory', JSON.stringify([]));
              historyIndex = -1;
            } catch (err) {
              // give up silently; nothing more we can do in localStorage
              console.warn('saveHistory: unable to persist even minimal history', err);
            }
          }
        } else {
          // not a quota problem -> rethrow so it surfaces
          throw e;
        }
      }

      // Try to persist historyIndex (best-effort)
      try {
        localStorage.setItem('historyIndex', historyIndex);
      } catch (e) {
        // ignore failures here (historyIndex is small)
        console.warn('saveHistory: failed to save historyIndex', e);
      }

      updateHistoryButtons();
    }
    
    function updateHistoryButtons() {
      document.getElementById('backBtn').disabled = historyIndex <= 0;
      document.getElementById('forwardBtn').disabled = historyIndex >= patternHistory.length - 1;
    }
    
    async function fetchCurrentPattern() {
      return await loadJSON('pattern.json');
    }
    
    async function drawPatternFromHistory(idx) {
      if (patternHistory[idx]) {
        const entry = patternHistory[idx];
        const pattern = entry.pattern || entry; // support legacy
        // prefer saved data that matches this pattern; fallback to current data.json
        let data = entry.data;
        if (!data) {
          data = await loadJSON('data.json');
        }
        const canvas = document.getElementById('patternCanvas');
        const width = data.canvas_width || 500;
        const height = data.canvas_height || 500;

        const adjusted = ensureCanvasSizeWithinLimits(width, height);
        if (adjusted.scale !== 1) {
          console.warn('Requested canvas size exceeds browser limits; drawing buffer downscaled by', adjusted.scale.toFixed(3));
        }
        canvas.width = adjusted.width;
        canvas.height = adjusted.height;
        applyCanvasDisplaySize(canvas, width, height);

        const drawScaleX = adjusted.width / width;
        const drawScaleY = adjusted.height / height;
        let maxX = 0, maxY = 0;
         pattern.forEach(tile => {
           if (tile.grid_x > maxX) maxX = tile.grid_x;
           if (tile.grid_y > maxY) maxY = tile.grid_y;
         });
         const cols = Math.max(1, maxX);
         const rows = Math.max(1, maxY);
         const tileSize = Math.min(width / cols, height / rows);
         const margin = tileSize * TILE_MARGIN_RATIO;
         const drawSize = tileSize - margin;
         const offsetX = (width - tileSize * cols) / 2;
         const offsetY = (height - tileSize * rows) / 2;
 
         const ctx = canvas.getContext('2d');

         ctx.clearRect(0, 0, adjusted.width, adjusted.height);
 
         // Fill background with white for margins
         ctx.fillStyle = "#fff";
         ctx.fillRect(0, 0, adjusted.width, adjusted.height);
 
         pattern.forEach(tile => {
           const x_disp = offsetX + (tile.grid_x - 1) * tileSize + margin / 2;
           const y_disp = offsetY + (tile.grid_y - 1) * tileSize + margin / 2;
           const x = x_disp * drawScaleX;
           const y = y_disp * drawScaleY;
           const size = drawSize * Math.min(drawScaleX, drawScaleY);
           drawTile(ctx, tile, x, y, size);
         });
       }
       updateHistoryButtons();
      // ensure canvas CSS fits the patternArea after drawing history
      recomputeCanvasSize();
     }
 
     // On new generation, always append to end of history (never erase forward)
    async function generateAndSaveHistory() {
      // Avoid starting another generation if one is already in progress
      if (isGenerationInProgress) return;
      // POST to /generate must include credentials so cookie (mirrored from localStorage) is sent
      const generateBtn = document.getElementById('generateBtn');
      // disable to avoid duplicate requests while working
      generateBtn.disabled = true;
      isGenerationInProgress = true;
      try {
        // capture previous pattern so we can detect change
        let previous = null;
        try { previous = await fetchCurrentPattern(); } catch (e) { previous = null; }
        const prevStr = previous ? JSON.stringify(previous) : null;

        // send generate request and wait for server to finish
        await fetch('/generate', { method: 'POST', credentials: 'same-origin' });

  // Poll for the new pattern.json until it differs from previous or timeout
  const timeoutMs = 60000; // 60s
        const pollInterval = 500; // 0.5s
        const deadline = Date.now() + timeoutMs;
        let pattern = null;
        while (Date.now() < deadline) {
          try {
            pattern = await fetchCurrentPattern();
            const patStr = JSON.stringify(pattern);
            if (prevStr === null || patStr !== prevStr) {
              break; // new pattern observed
            }
          } catch (e) {
            // transient parse/fetch error -> keep polling
          }
          await new Promise(r => setTimeout(r, pollInterval));
        }
        // final attempt if still null
        if (!pattern) {
          try { pattern = await fetchCurrentPattern(); } catch (e) { pattern = []; }
        }

        const data = await loadJSON('data.json'); // capture the data that produced this pattern
        // Always append new pattern+data to end of history
        patternHistory.push({ pattern: pattern, data: data });
        // Limit history to 100 generations
        if (patternHistory.length > 100) {
          patternHistory = patternHistory.slice(patternHistory.length - 100);
        }
        historyIndex = patternHistory.length - 1;
        saveHistory();
        drawPatternFromHistory(historyIndex);
      } finally {
        isGenerationInProgress = false;
        generateBtn.disabled = false;
        // If any changes happened while we were generating, run one follow-up generation
        if (needsGenerateAfterCurrent) {
          needsGenerateAfterCurrent = false;
          // schedule shortly so we don't recurse deeply
          setTimeout(() => {
            generateAndSaveHistory();
          }, 50);
        }
      }
    }

    document.getElementById('generateBtn').onclick = generateAndSaveHistory;

    document.getElementById('backBtn').onclick = function() {
      if (historyIndex > 0) {
        historyIndex--;
        saveHistory();
        drawPatternFromHistory(historyIndex);
      }
    };

    document.getElementById('forwardBtn').onclick = function() {
      if (historyIndex < patternHistory.length - 1) {
        historyIndex++;
        saveHistory();
        drawPatternFromHistory(historyIndex);
      }
    };

    // Debounced auto-save and generate
    async function autoSaveAndGenerate() {
      const data = {};
      data.knob_down = parseInt(document.getElementById('knob_down').value);
      data.slider = parseInt(document.getElementById('slider').value);
      data.switch = document.querySelector('input[name="switch"]:checked').value;
      data.canvas_width = parseInt(document.getElementById('canvas_width').value);
      data.canvas_height = parseInt(document.getElementById('canvas_height').value);
      for (let i = 0; i <= 9; i++) {
        const btnKey = `button_${i}`;
        const swatch = document.getElementById(btnKey + '_swatch');
        const color = (swatch && swatch.dataset && swatch.dataset.color) ? swatch.dataset.color : DEFAULT_BUTTON_COLORS[i];
        const state = (swatch && !swatch.classList.contains('inactive')) ? "on" : "off";
        data[btnKey] = { state: state, color: color };
      }
      await postJSON('/data.json', data);

      // Debounce pattern generation. If a generation is already in progress, queue one follow-up.
      if (debounceTimer) clearTimeout(debounceTimer);
      if (!isGenerationInProgress) {
        debounceTimer = setTimeout(generateAndSaveHistory, 400);
      } else {
        // mark that we need one generation after current finishes
        needsGenerateAfterCurrent = true;
        debounceTimer = null;
      }
    }

    // Overlay logic
    const settingsOverlay = document.getElementById('settingsOverlay');
    const showSettingsTab = document.getElementById('showSettingsTab');
    const closeSettingsBtn = document.getElementById('closeSettingsBtn');
    const settingsPanel = document.getElementById('settingsPanel');

    showSettingsTab.onclick = function() {
      settingsOverlay.style.display = 'flex';
      showSettingsTab.style.display = 'none';
    };
    closeSettingsBtn.onclick = function() {
      settingsOverlay.style.display = 'none';
      showSettingsTab.style.display = 'flex';
    };
    // Click outside panel closes overlay
    settingsOverlay.onclick = function(e) {
      if (e.target === settingsOverlay) {
        settingsOverlay.style.display = 'none';
        showSettingsTab.style.display = 'flex';
      }
    };

    // Initial load
    // Ensure session cookie mirrors localStorage on every load before requests start
    ensureSessionId();
    fillForm().then(attachAutoSave);
    loadHistory();
    // If history exists, draw last pattern, else draw current
    if (patternHistory.length > 0) {
      drawPatternFromHistory(historyIndex);
    } else {
      drawPattern();
    }

    // Generate drawing instructions from a pattern array
    function getDrawingInstructions(pattern) {
      let instructions = [];
      pattern.forEach((tile, idx) => {
        instructions.push(
          `Tile ${idx + 1}: Type=${tile.tile}, Grid=(${tile.grid_x},${tile.grid_y}), Rotation=${tile.rotation || 0}, ` +
          `Background=${tile.color_fundo}, PatternColor=${tile.color_padrao}`
        );
      });
      return instructions.join('\n');
    }

    // Print button logic
    document.getElementById('printBtn').onclick = function() {
      const entry = patternHistory[historyIndex];
      if (!entry) return;
      // entry may be { pattern, data } or legacy pattern array
      const pattern = entry.pattern || entry;
      const instructions = getDrawingInstructions(pattern);
      const blob = new Blob([instructions], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `pepe_pattern_instructions.txt`;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    };

    // Keep displayed canvas scaled properly when the window resizes
    // Recompute canvas CSS size when the window or pattern area change size
    function recomputeCanvasSize() {
      const canvas = document.getElementById('patternCanvas');
      const iw = parseInt(canvas.dataset.intrinsicWidth || 0, 10);
      const ih = parseInt(canvas.dataset.intrinsicHeight || 0, 10);
      if (iw && ih) applyCanvasDisplaySize(canvas, iw, ih);
    }
    window.addEventListener('resize', recomputeCanvasSize);
    // Observe patternArea size changes (use ResizeObserver if available)
    const patternAreaEl = document.getElementById('patternArea');
    if (window.ResizeObserver && patternAreaEl) {
      const ro = new ResizeObserver(recomputeCanvasSize);
      ro.observe(patternAreaEl);
    }
    // Observe controls size changes so we can reserve the correct bottom space
    const controlsEl = document.getElementById('controls');
    if (window.ResizeObserver && controlsEl) {
      const cro = new ResizeObserver(recomputeCanvasSize);
      cro.observe(controlsEl);
    }

    // ---- Potentiometer UI: smoother dragging + single save on release ----
    (function(){
      const min = 1, max = 10;
      const knob = document.getElementById('knob_down');
      const potFront = document.getElementById('pot_front');
      const pot = document.getElementById('potentiometer');
      if (!knob || !potFront || !pot) return;

      function valueToRatio(v){
        return (v - min) / (max - min);
      }
      function ratioToAngle(r){
        return -135 + r * 270; // returns angle in [-135,135]
      }

      // sweep geometry (we'll operate with a normalized "extended" angle range to avoid seam ambiguity)
      const sweepStart = 225; // equivalent of -135
      const sweepSpan = 270;  // degrees
      const sweepEnd = sweepStart + sweepSpan; // 225..495 in extended domain

      // initialize from existing input value
      const initialVal = parseInt(knob.value || min, 10);
      let currentRatio = Math.max(0, Math.min(1, valueToRatio(initialVal)));
      // compute lastAngleNormalized in the extended domain [sweepStart, sweepEnd]
      let lastAngleNorm = ratioToAngle(currentRatio);
      // convert lastAngleNorm (which is -135..135) into extended domain 225..495
      if (lastAngleNorm < sweepStart) lastAngleNorm += 360;
      // apply initial visible transform
      potFront.style.transform = `rotate(${ratioToAngle(currentRatio)}deg) scale(0.5)`;

      // smoother interaction: update transform continuously, only persist when user releases
      let dragging = false;
      let rafPending = false;
      let targetDisplayAngle = ratioToAngle(currentRatio);
      let targetNormalizedAngle = lastAngleNorm;

      function applyTransform(displayAngle, normalizedAngle){
        // apply rotation + keep scale
        potFront.style.transform = `rotate(${displayAngle}deg) scale(0.5)`;
        // remember normalized angle so small moves across the seam pick the nearest arc
        if (typeof normalizedAngle === 'number') lastAngleNorm = normalizedAngle;
      }

      function pagePos(e){
        if (e.touches && e.touches[0]) return {x: e.touches[0].clientX, y: e.touches[0].clientY};
        return {x: e.clientX, y: e.clientY};
      }

      // Convert a pointer page position into a ratio [0..1]. Uses lastAngleNorm to disambiguate
      // angles near the seam so movement stays continuous relative to where the knob currently is.
      function pointerToRatioAndAngles(p){
        const rect = pot.getBoundingClientRect();
        const cx = rect.left + rect.width/2;
        const cy = rect.top + rect.height/2;
        const ang = (Math.atan2(p.y - cy, p.x - cx) * 180 / Math.PI + 360) % 360; // 0..360

        // Lift candidate into the same extended domain as lastAngleNorm so we can choose the nearest wrap
        let candidate = ang;
        if (candidate < sweepStart) candidate += 360; // now candidate approximately in [sweepStart, sweepStart+360)

        // Choose the candidate (possibly shifted by +/-360) that's closest to lastAngleNorm
        // Try adjustments of -360, 0, +360 and pick minimal delta
        const candidates = [candidate - 360, candidate, candidate + 360];
        let best = candidates[0];
        let bestDelta = Math.abs(candidates[0] - lastAngleNorm);
        for (let i = 1; i < candidates.length; i++){
          const d = Math.abs(candidates[i] - lastAngleNorm);
          if (d < bestDelta) { bestDelta = d; best = candidates[i]; }
        }

        // Clamp into sweep range
        const clamped = Math.max(sweepStart, Math.min(sweepEnd, best));
        const ratio = Math.max(0, Math.min(1, (clamped - sweepStart) / sweepSpan));

        // convert clamped back to a displayable angle in [-180,180] for CSS rotate
        let display = clamped;
        if (display > 360) display -= 360;
        // ensure display is within [-180,180] (not strictly necessary, but keeps values sane)
        if (display > 180) display -= 360;

        return { ratio: ratio, displayAngle: display, normalizedAngle: clamped };
      }

      function scheduleApply(displayAngle, normalizedAngle){
        targetDisplayAngle = displayAngle;
        targetNormalizedAngle = normalizedAngle;
        if (rafPending) return;
        rafPending = true;
        requestAnimationFrame(()=>{
          applyTransform(targetDisplayAngle, targetNormalizedAngle);
          rafPending = false;
        });
      }

      function updateFromPointer(e){
        const p = pagePos(e);
        const result = pointerToRatioAndAngles(p);
        currentRatio = result.ratio;
        // While dragging, remove transitions so the front follows the finger precisely
        if (!rafPending) scheduleApply(result.displayAngle, result.normalizedAngle);
      }

      function onPointerDown(e){
        dragging = true;
        potFront.style.transition = 'none';
        if (e.pointerId) pot.setPointerCapture && pot.setPointerCapture(e.pointerId);
        updateFromPointer(e);
      }

      function onPointerUp(e){
        if (!dragging) return;
        dragging = false;
        // restore CSS transition for a smooth settle
        potFront.style.transition = 'transform 120ms linear';
        // compute final integer value and persist
        const finalVal = Math.round(min + currentRatio * (max - min));
        knob.value = finalVal;
        // apply final transform (with transition)
        const finalRatio = Math.max(0, Math.min(1, valueToRatio(finalVal)));
        const finalAngle = ratioToAngle(finalRatio);
        // normalize to extended domain for lastAngleNorm bookkeeping
        let finalNorm = finalAngle;
        if (finalNorm < sweepStart) finalNorm += 360;
        applyTransform(finalAngle, finalNorm);
        try{ autoSaveAndGenerate(); }catch(e){}
      }

      // attach pointer events
      pot.addEventListener('pointerdown', onPointerDown);
      window.addEventListener('pointermove', (e)=>{ if (dragging) updateFromPointer(e); });
      window.addEventListener('pointerup', onPointerUp);

      // touch fallback
      pot.addEventListener('touchstart', (e)=>{ onPointerDown(e.touches ? e.touches[0] : e); e.preventDefault(); }, {passive:false});
      window.addEventListener('touchmove', (e)=>{ if (dragging) { updateFromPointer(e.touches ? e.touches[0] : e); e.preventDefault(); } }, {passive:false});
      window.addEventListener('touchend', (e)=>{ onPointerUp(e.changedTouches ? e.changedTouches[0] : e); });
    })();
    // Auto-hide controls on small screens: show on interaction, hide after idle
    (function(){
      const controls = document.getElementById('controls');
      const handle = document.getElementById('controlsHandle');
      if (!controls || !handle) return;

      const IDLE_MS = 2500; // hide after 2.5s of inactivity
      let idleTimer = null;
      let isManualOpen = false; // user explicitly opened controls via handle

      function isSmallViewport() {
        return window.innerHeight < 1700 || window.innerWidth < 1700; // heuristic
      }

      function showControls() {
        controls.classList.remove('hidden');
        controls.classList.add('visible');
        handle.style.opacity = '0';
        handle.style.pointerEvents = 'none';
      }

      function hideControls() {
        if (isManualOpen) return; // don't auto-hide if user pinned it open
        controls.classList.add('hidden');
        controls.classList.remove('visible');
        handle.style.opacity = '1';
        handle.style.pointerEvents = 'auto';
      }

      function resetIdle() {
        if (idleTimer) clearTimeout(idleTimer);
        if (isSmallViewport()) {
          idleTimer = setTimeout(hideControls, IDLE_MS);
        }
      }

      // Show on pointer/move/touch
      ['mousemove','pointermove','touchstart','touchmove'].forEach(evt => {
        window.addEventListener(evt, () => {
          showControls();
          resetIdle();
        }, { passive: true });
      });

      // Handle: toggle manual open/close on click or tap
      handle.addEventListener('click', (e) => {
        isManualOpen = !isManualOpen;
        if (isManualOpen) {
          showControls();
        } else {
          hideControls();
        }
      });

      // Recompute behaviour on resize
      window.addEventListener('resize', () => {
        if (!isSmallViewport()) {
          // always visible on large screens
          controls.classList.remove('hidden');
          controls.classList.add('visible');
          handle.style.opacity = '0';
        } else {
          // start hidden on small screens
          hideControls();
          resetIdle();
        }
      });

      // initialize
      if (isSmallViewport()) {
        hideControls();
        resetIdle();
      } else {
        showControls();
      }
    })();
  </script>
</body>
</html>